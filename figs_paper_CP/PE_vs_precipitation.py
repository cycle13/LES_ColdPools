import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt


# import ../thermodynamic_profiles
# from thermodynamic_profiles import eos
label_size = 15
plt.rcParams['xtick.labelsize'] = label_size
plt.rcParams['ytick.labelsize'] = label_size
plt.rcParams['axes.labelsize'] = 18
# plt.rcParams['xtick.direction']='out'
# plt.rcParams['ytick.direction']='out'
plt.rcParams['legend.fontsize'] = 10
plt.rcParams['lines.linewidth'] = 3
plt.rcParams['grid.linewidth'] = 20


def main():
    'geometry'
    global nz, dz
    dz = 25
    nz = 2e3/dz
    # nz = 3

    # define parameters
    global Rd, Rv, eps_v, eps_vi
    Rd = 287.1
    Rv = 461.5
    eps_v = 0.62210184182
    eps_vi = 1.60745384883
    global g, cpd, cpv, kappa, Lv
    g = 9.80665
    cpd = 1004.0
    cpv = 1859.0
    Lv = 2264.705e3       # sensible latent heat of water evaporation
    kappa = 0.285956175299
    global rho_w
    rho_w = 997 #kg/m3
    global T_tilde, p_tilde, sd_tilde
    T_tilde = 298.15
    p_tilde = 100000.0
    sd_tilde = 6864.8

    'surface values'
    global Pg, Tg, qtg
    Pg = 1.0e5
    Tg = 300.0
    qtg = 0.0
    # sg = entropy_dry(Pg, Tg, qtg, 0.0, 0.0)
    # sg = 6e3

    # compute reference pressure and density profiles (assuming dry thermodynamics)
    p, al_d = compute_pressure_profile_dry()
    rho_d = 1./al_d


    ''' evaporation parameters '''
    z0 = 800.       # height of evaporation
    k0 = np.int(z0/dz)
    theta0 = 298.   # temperature at level of evaporation
    q0 = 298.       # moisture at level of evaporatio
    evap = 0.1      # fraction of rain water that is evaporated
    ''' rain event '''
    z_BL = 1e3      # height of sub-cloud layer [m]
    A = 1e3**2      # area of precipitation cell
    intensity = 5   # [mm/h]
    tau = 1         # duration of rain event


    ''' (1) compute precipitation, given potential energy '''
    ''' dry '''
    PE0 = -0.8e11
    # PE0 = -0.5e11
    # evaporated water:     V * rho_w * evap
    # volume:               V = I * A * tau, A: area, I: intensity, tau: duration
    # released heat:        Q = Lv * V * rho_w * evap
    # temperature change:   Q = dT * cp <<>> dT = Q / cp
    # >> Lv * V * rho_w * evap = dT * cp >> V = dT * cp / (Lv * rho_w * evap)
    def compute_intensity_from_PE(PE0, rho_d, tau, A, z0):
        V = A*z_BL
        dTh = PE0 * theta0 / (g*z0*rho_d[k0]*V)
        dT = dTh / exner_c(p[k0])
        I = cpd * (-dT) * (rho_d[k0]*A*z_BL) / (evap*rho_w*tau*A*Lv)
        print('   PE ref:             ' + str(PE0))
        print('   dTh:                ' + str(np.round(dTh, 2)) + ' K')
        print('   dT:                 ' + str(np.round(dT, 2)) + ' K')
        return I
    print('tau: ' + str(tau) + ' h, area: '+str(A) + 'm2')
    I_ref = compute_intensity_from_PE(PE0, rho_d, tau, A, z0)
    P = I_ref * A * tau
    height = P/A
    print('   Precip. intensity:  ' + str(np.round(I_ref*1e3,0)) + ' mm/h')
    print('   Precip. total:      ' + str(np.round(P,2)) + ' m^3')
    print('   height watercolumn: ' + str(np.round(1e3*height,0)) + ' mm')
    # This corresponds to the cooling generated by the fractional evaporation of rain from a cell of area 1km2 that
    # precipitates at moderate intensity of 5 mm/h for half an hour at an evaporation rate of 10%
    tau_ = height / (intensity*1e-3)
    intensity_ = height / tau * 1e3
    print('if intensity is '+str(intensity)+'mm/h, then duration is: tau='+str(np.round(tau_,2))+' h')
    print('if duration is '+str(tau)+'h, then intensity is: I='+str(np.round(intensity_,2))+' mm/h')

    print('')
    print('PE range: ')
    PE_range = 2.**np.arange(-1, 4)
    print(PE_range)
    print('tau: ' + str(tau) + ' h, area: '+str(A) + 'm2')
    I = compute_intensity_from_PE(PE_range*PE0, rho_d, tau, A, z0)
    # P = -PE0*PE_range * theta0 / (g * z0 * rho_d[k0]) * cpd / (rho_w * evap) / exner_c(p[k0])
    P = I * A * tau
    height = P / A
    print('   Precip. intensity:  ' + str(np.round(I * 1e3, 0)) + ' mm/h')
    print('   Precip. total:      ' + str(np.round(P, 2)) + ' m^3')
    print('   height watercolumn: ' + str(np.round(1e3 * height, 0)) + ' mm')



    fig, [ax0, ax1, ax2] = plt.subplots(1, 3, figsize=(20,5))
    ax0.plot(PE_range, P, '-o')
    ax0.set_xlabel('PE/PE_ref')
    ax1.plot(PE0*PE_range, P, '-o')
    ax1.set_xlabel('PE/PE_ref')
    ax2.bar(PE_range, I*1e3, align='center', facecolor='lightblue')
    ax2.set_xlabel('PE/PE_ref')
    ax2.set_ylabel('Intensity [mm/h]')
    plt.subplots_adjust(bottom=0.12, right=.95, left=0.07, top=0.9, wspace=0.25)
    plt.savefig('./preciptation_run5.png')

    print(I*1e3)
    aux = PE_range[0]*np.ones(np.int(I[0]*1e3))
    aux = np.append(aux, np.ones(np.int(I_ref*1e3)))
    aux = np.append(aux, PE_range[1]*np.ones(np.int(I[1]*1e3)))
    aux = np.append(aux, PE_range[2]*np.ones(np.int(I[2]*1e3)))
    aux = np.append(aux, PE_range[3]*np.ones(np.int(I[3]*1e3)))
    aux = np.append(aux, PE_range[4]*np.ones(np.int(I[4]*1e3)))
    print(I*1e3)
    print(PE_range)
    print(aux)

    fig, [ax0, ax1, ax2] = plt.subplots(1, 3, figsize=(20, 5))

    ax0.plot(PE_range, np.round(I * 1e3, 0), '-o')
    ax0.set_xlabel('PE/PE_ref')
    ax1.hist(aux)
    ax1.set_xlabel('PE/PE_ref')
    ax1.set_ylabel('Intensity [mm/h]')
    # ax2.hist(np.round(I * 1e3, 0), '-o')
    ax2.bar(PE_range, I*1e3, align='center', facecolor='lightblue')
    # plt.bar(range(len(D)), D.values(), align='center')
    ax2.set_xlabel('PE/PE_ref')
    ax2.set_ylabel('Intensity [mm/h]')
    plt.savefig('./preciptation_run5_hist.png')



    # ''' moist '''
    #
    # T0 = theta
    # print('!!')
    # qt0 = 1e-3
    # qv0 = qt0
    # # evaporated rain
    # # dqv =
    #
    #
    # # rho = 1./alpha(T, p, qt, qv)
    # buoy = g*rho_d[k]*(alpha_tot(T0, p[k], qt0, qv0))

    return



# -----------------------------------------
def compute_pressure_profile_dry():
    # compute entropy from pressure and temperature
    # sg = Thermodynamics.entropy(self.Pg, self.Tg, self.qtg, 0.0, 0.0)
    def entropy_dry(pd, T, qt, ql, qi):
        print 'entropy dry'
        sd_c = sd_tilde + cpd * np.log(T / T_tilde) - Rd * np.log(pd / p_tilde)
        return sd_c

    # compute Temperature from pressure and entropy (dry)
    def eos(pd, s, qt):
        ql = np.zeros(pd.shape)
        qi = np.zeros(pd.shape)
        eos_c = T_tilde * (np.exp((s - sd_tilde + Rd * np.log(pd / p_tilde)) / cpd))
        return eos_c, ql, qi

    def rhs(p, z):
        ql = 0.0
        qi = 0.0
        # # given sfc values for pressure, temperature and moisture
        # # >> compute sfc entropy (= constant value throught atmosphere for reference profile being defines as constant-entropy profile)
        # # compute temperature from pressure and entropy (at any given height)
        T, ql, qi = eos(np.exp(p), sg, qtg)
        rhs_ = -g / (Rd * T * (1.0 - qtg + eps_vi * (qtg - ql - qi)))
        return rhs_

    sg = entropy_dry(Pg, Tg, qtg, 0.0, 0.0)
    p0 = np.log(Pg)
    # Construct arrays for integration points
    z_ = np.array(np.arange(nz) * dz)
    # Perform the integration
    p = odeint(rhs, p0, z_, hmax=1.0)[:, 0]  # type: object
    # p_half = odeint(rhs, p0, z_half, hmax=1.0)[1:, 0]
    p = np.exp(p)
    # temperature[k], ql[k], qi[k] = Thermodynamics.eos(p_[k], self.sg, self.qtg)
    # print('...', sg, qtg)
    T, ql, qi = eos(p, sg, qtg)
    # qv[k] = self.qtg - (ql[k] + qi[k])
    qv = np.zeros(p.shape)
    # alpha[k] = Thermodynamics.alpha(p_[k], temperature[k], self.qtg, qv[k])
    al = alpha_tot(T, p, qtg, qv)
    # al = alpha_dry(T, p)

    fig, axes = plt.subplots(1, 3, figsize=(24, 10))
    ax = axes[0]
    ax.plot(p, z_, '-')
    ax.set_title('pressure')
    ax = axes[1]
    ax.plot(T, z_, '-')
    ax.set_title('temperature')
    ax = axes[2]
    ax.plot(1./al, z_, '-')
    ax.plot([np.amin(1./al), np.amax(1./al)], [800, 800], 'k')
    # # ax.plot([3.0, 3.0],[0, 5000], 'k')
    ax.plot([1./al[np.int(800. / dz)], 1./al[np.int(800. / dz)]], [0, 2e3], 'k')
    ax.set_title('rho')
    plt.savefig('./thermodynamic_profiles_pycles.png')
    plt.close()

    return p, al


# -----------------------------------------

def alpha_tot(T, p0, qt, qv):
    # qd*alpha_dry + qv*alpha_moist, with qd=1-qt
    return Rd*T/p0 * (1.-qt+qv*eps_vi)

def alpha_dry(T, p0):
    return Rd*T / p0

def alpha_moist(T, p0):
    return Rv*T/p0

def exner_c(p0):
    return pow((p0/p_tilde),kappa)

# -----------------------------------------

if __name__ == '__main__':
    main()