import os
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt


# import ../thermodynamic_profiles
# from thermodynamic_profiles import eos

execfile('settings.py')
label_size = 15
plt.rcParams['xtick.labelsize'] = label_size
plt.rcParams['ytick.labelsize'] = label_size
plt.rcParams['axes.labelsize'] = 21
# plt.rcParams['xtick.direction']='out'
# plt.rcParams['ytick.direction']='out'
plt.rcParams['legend.fontsize'] = 10
plt.rcParams['lines.linewidth'] = 3
plt.rcParams['grid.linewidth'] = 20


def main():
    # # path_out_figs = '/nbi/ac/cond1/meyerbe/paper_CP_single'
    # path_out_figs = '/nbi/home/meyerbe/paper_CP'

    'geometry'
    global nz, dz
    dz = 25
    nz = 2e3/dz
    # nz = 3

    # define parameters
    global Rd, Rv, eps_v, eps_vi
    Rd = 287.1
    Rv = 461.5
    eps_v = 0.62210184182
    eps_vi = 1.60745384883
    global g, cpd, cpv, kappa, Lv
    g = 9.80665
    cpd = 1004.0
    cpv = 1859.0
    Lv = 2264.705e3       # sensible latent heat of water evaporation
    kappa = 0.285956175299
    global rho_w
    rho_w = 997 #kg/m3
    global T_tilde, p_tilde, sd_tilde
    T_tilde = 298.15
    p_tilde = 100000.0
    sd_tilde = 6864.8

    'surface values'
    global Pg, Tg, qtg
    Pg = 1.0e5
    Tg = 300.0
    qtg = 0.0
    # sg = entropy_dry(Pg, Tg, qtg, 0.0, 0.0)
    # sg = 6e3

    # compute reference pressure and density profiles (assuming dry thermodynamics)
    p_ref, al_d = compute_pressure_profile_dry()
    rho_d = 1./al_d


    ''' evaporation parameters '''
    z0 = 800.       # height of evaporation
    theta0 = 298.   # temperature at level of evaporation
    q0 = 298.       # moisture at level of evaporatio
    # evap = 0.1      # fraction of rain water that is evaporated
    ''' rain event '''
    z_BL = 1e3      # height of sub-cloud layer [m]
    A = 1e3**2      # area of precipitation cell
    intensity = 5   # [mm/h]
    tau = 1         # duration of rain event


    ''' (1) compute precipitation, given potential energy '''
    ''' dry '''
    PE_ref = -0.8e11
    # PE_ref = -0.5e11
    # evaporated water:     V * rho_w * evap
    # volume:               V = I * A * tau, A: area, I: intensity, tau: duration
    # released heat:        Q = Lv * V * rho_w * evap
    # temperature change:   Q = dT * cp <<>> dT = Q / cp
    # >> Lv * V * rho_w * evap = dT * cp >> V = dT * cp / (Lv * rho_w * evap)
    print('tau: ' + str(tau) + ' h, area: '+str(A) + 'm2')
    I_ref = compute_intensity_from_PE(PE_ref, rho_d, p_ref, tau, A, z0, z_BL, theta0)
    P = I_ref * A * tau
    height = P/A
    print('   Precip. intensity:  ' + str(np.round(I_ref*1e3,0)) + ' mm/h')
    print('   Precip. total:      ' + str(np.round(P,2)) + ' m^3')
    print('   height watercolumn: ' + str(np.round(1e3*height,0)) + ' mm')
    # This corresponds to the cooling generated by the fractional evaporation of rain from a cell of area 1km2 that
    # precipitates at moderate intensity of 5 mm/h for half an hour at an evaporation rate of 10%
    tau_ = height / (intensity*1e-3)
    intensity_ = height / tau * 1e3
    print('if intensity is '+str(intensity)+'mm/h, then duration is: tau='+str(np.round(tau_,2))+' h')
    print('if duration is '+str(tau)+'h, then intensity is: I='+str(np.round(intensity_,2))+' mm/h')

    ''' (2) plot histogram '''
    print('')
    print('PE range: ')
    PE_range = 2. ** np.arange(-1, 4)
    print(PE_range)
    print('tau: ' + str(tau) + ' h, area: ' + str(A) + 'm2')
    I = compute_intensity_from_PE(PE_range * PE_ref, rho_d, p_ref, tau, A, z0, z_BL, theta0)
    # P = -PE_ref*PE_range * theta0 / (g * z0 * rho_d[k0]) * cpd / (rho_w * evap) / exner_c(p[k0])
    P = I * A * tau
    height = P / A
    print('   Precip. intensity:  ' + str(np.round(I * 1e3, 0)) + ' mm/h')
    print('   Precip. total:      ' + str(np.round(P, 2)) + ' m^3')
    print('   height watercolumn: ' + str(np.round(1e3 * height, 0)) + ' mm')
    plot_histogram_PE_vs_Intensity(PE_range, P, PE_ref, I, I_ref, path_out_figs)


    ''' (3) plot PE vs. R (run5)'''
    dTh_ref = 3
    rstar_ref = 1000
    zstar_ref = 1000
    # run5
    dTh = 5
    r_params = [500, 1100, 1600, 2300]
    r_params_ = [500, 1000, 1100, 1600, 2300]
    z_params = [1000]
    PE_array = [0.5, 2, 4, 8]
    PE_array_log = 2. ** np.arange(-1, 4)
    # print('PE: ' + str(PE_array))
    n_params = len(r_params)
    plot_PE_vs_R(r_params, z_params, n_params, dTh, rstar_ref, zstar_ref, dTh_ref, PE_array, PE_array_log, 
                 path_out_figs)


    # ''' moist '''
    #
    # T0 = theta
    # print('!!')
    # qt0 = 1e-3
    # qv0 = qt0
    # # evaporated rain
    # # dqv =
    #
    #
    # # rho = 1./alpha(T, p, qt, qv)
    # buoy = g*rho_d[k]*(alpha_tot(T0, p[k], qt0, qv0))

    return



# -----------------------------------------
def plot_histogram_PE_vs_Intensity(PE_range, P, PE_ref, I, I_ref, path_out_figs):

    fig, [ax0, ax1, ax2] = plt.subplots(1, 3, figsize=(20, 6))
    ax0.plot(PE_range, P, '-o')
    ax0.set_xlabel(r'PE / PE$_0$')
    ax1.plot(PE_ref * PE_range, P, '-o')
    ax1.set_xlabel('PE / PE_ref')
    ax2.bar(PE_range, I * 1e3, align='center', facecolor='lightblue')
    ax2.set_xlabel('PE / PE_ref')
    ax2.set_ylabel('Intensity [mm/h]')
    plt.subplots_adjust(bottom=0.2, right=.95, left=0.07, top=0.9, wspace=0.25)
    plt.savefig('./preciptation_run5.png')

    print(I * 1e3)
    aux = PE_range[0] * np.ones(np.int(I[0] * 1e3))
    aux = np.append(aux, np.ones(np.int(I_ref * 1e3)))
    aux = np.append(aux, PE_range[1] * np.ones(np.int(I[1] * 1e3)))
    aux = np.append(aux, PE_range[2] * np.ones(np.int(I[2] * 1e3)))
    aux = np.append(aux, PE_range[3] * np.ones(np.int(I[3] * 1e3)))
    aux = np.append(aux, PE_range[4] * np.ones(np.int(I[4] * 1e3)))
    print(I * 1e3)
    print(PE_range)
    print(aux)

    fig_name = 'precipitation_run5_hist.png'
    fig, [ax0, ax1, ax2] = plt.subplots(1, 3, figsize=(20, 6))
    ax0.plot(PE_range, np.round(I * 1e3, 0), '-o')
    ax0.set_xlabel(r'PE / PE$_0$')
    ax1.hist(aux)
    ax1.set_xlabel(r'PE / PE$_0$')
    ax1.set_ylabel('Intensity [mm/h]')
    # ax2.hist(np.round(I * 1e3, 0), '-o')
    ax2.bar(PE_range, I * 1e3, align='center', facecolor='lightblue')
    # plt.bar(range(len(D)), D.values(), align='center')
    ax2.set_xlabel(r'PE / PE$_0$')
    ax2.set_ylabel('Intensity [mm/h]')
    for ax in [ax0, ax1, ax2]:
        ax.set_xticklabels([np.int(ti) for ti in ax.get_xticks()])
        ax.set_yticklabels([np.int(ti) for ti in ax.get_yticks()])
    plt.subplots_adjust(bottom=0.2, right=.95, left=0.07, top=0.9, wspace=0.25)
    #plt.savefig('./preciptation_run5_hist.png')
    plt.savefig(os.path.join(path_out_figs, fig_name))
    return
# -----------------------------------------
def plot_PE_vs_R(r_params, z_params, n_params, dTh, rstar_ref, zstar_ref, dTh_ref,
                 PE_array, PE_array_log,
                 path_out_figs):
    fig_name = 'PE_scaling_run5.png'

    r_params_ = list(r_params)
    i = 0
    while (rstar_ref>r_params[i]) and (i<len(r_params)):
        i+=1
    r_params_.insert(i, rstar_ref)
    print('TESTING: ', i, r_params[i])
    print(r_params)
    print(r_params_)

    ''' envelope '''
    Lx = 6e3
    dx_ = 10
    nx_ = Lx / dx_
    x_arr = np.arange(0, Lx, dx_)
    ic = np.int(nx_ / 2)
    xc = x_arr[ic]
    # print nx_, ic, xc
    #
    zmax = np.zeros((n_params + 1, nx_))
    for istar in range(n_params):
        zstar = z_params[0]
        rstar = r_params[istar]
        irstar = np.int(np.double(rstar) / dx_)
        x_arr_ = np.array(x_arr, copy=True)
        x_arr_[:ic - irstar] = rstar + xc
        x_arr_[ic + irstar:] = rstar + xc
        zmax[istar, :] = zstar * np.cos((x_arr_ - xc) / rstar * np.pi / 2) ** 2
    x_arr_ = np.array(x_arr, copy=True)
    irstar = np.int(np.double(rstar_ref) / dx_)
    x_arr_[:ic - irstar] = rstar_ref + xc
    x_arr_[ic + irstar:] = rstar_ref + xc
    zmax[-1, :] = zstar_ref * np.cos((x_arr_ - xc) / rstar_ref * np.pi / 2) ** 2

    fig, (ax0, ax1) = plt.subplots(1, 2, figsize=(16, 5))
    for istar in range(n_params):
        zstar = z_params[0]
        rstar = r_params[istar]
        ax0.plot(x_arr - xc, zmax[istar, :], label='dTh' + str(dTh) + ', z*' + str(zstar) + ', r*' + str(rstar))
    ax0.plot(x_arr - xc, zmax[-1], 'k',
             label='dTh' + str(dTh_ref) + ', z*' + str(zstar_ref) + ', r*' + str(rstar_ref))
    ax0.set_ylabel('Height z  [km]', fontsize=21)
    ax0.set_ylim(0, z_params[-1] + 100)

    ax0.legend(loc='upper right', bbox_to_anchor=(-0.2, 1.0),
               fancybox=True, ncol=1)

    ax1.plot(r_params_, PE_array_log, 'k', linewidth=0.5)
    ax1.plot(r_params, PE_array, '--k', linewidth=0.5)
    for istar in range(n_params):
        # #     axes[0].plot(np.log2(PE_array[istar]), r_params_[istar], 'o', markersize=10, markeredgecolor='w', )
        ax1.plot(r_params[istar], PE_array[istar], 'o', markersize=10, markeredgecolor='w', )
    ax1.plot(r_params_[1], PE_array_log[1], 'ko', markersize=10, markeredgecolor='w', )

    # ax1.legend(loc='upper left', bbox_to_anchor=(1.05, 1.0),
    #            fancybox=True, ncol=1)
    ax1.set_ylabel(r'PE / PE$_0$')
    ax1.set_xlim(400, 2500)
    ax1.set_ylim(0, 8.5)
    for ax in [ax0, ax1]:
        ax.set_xlabel('Radius r  [km]')
    ax0.set_xticklabels([np.int(ti*1e-3) for ti in ax0.get_xticks()])
    ax1.set_xticklabels([np.round(ti*1e-3,1) for ti in ax1.get_xticks()])
    ax0.set_yticklabels([np.round(ti*1e-3,0) for ti in ax0.get_yticks()])
    ax1.set_yticklabels([np.int(ti) for ti in ax.get_yticks()])
    for label in ax1.yaxis.get_ticklabels()[3::2]:
        label.set_visible(False)
    ax0.yaxis.get_ticklabels()[1].set_visible(False)
    ax0.yaxis.get_ticklabels()[2].set_visible(False)
    ax0.yaxis.get_ticklabels()[3].set_visible(False)
    ax0.yaxis.get_ticklabels()[4].set_visible(False)
    ax1.yaxis.get_ticklabels()[6].set_visible(False)
    plt.tight_layout()
    plt.subplots_adjust(bottom=0.2, right=.85, left=0.2, top=0.9, wspace=0.25)
    plt.savefig(os.path.join(path_out_figs, fig_name))
    plt.close(fig)
    return
# -----------------------------------------
def compute_intensity_from_PE(PE0, rho_d, p, tau, A, z0, z_BL, theta0):
    ''' evaporation parameters '''
    # tau         # duration of rain event
    # A           # area of precipitation cell
    # z0          # height of evaporation
    # z_BL        # height of sub-cloud layer [m]
    # theta0      # temperature at level of evaporation
    # p           # reference pressure
    # rho_d       # reference density profile
    k0 = np.int(z0 / dz)
    evap = 0.1  # fraction of rain water that is evaporated

    V = A*z_BL
    dTh = PE0 * theta0 / (g*z0*rho_d[k0]*V)
    dT = dTh / exner_c(p[k0])
    I = cpd * (-dT) * (rho_d[k0]*A*z_BL) / (evap*rho_w*tau*A*Lv)
    print('   PE ref:             ' + str(PE0))
    print('   dTh:                ' + str(np.round(dTh, 2)) + ' K')
    print('   dT:                 ' + str(np.round(dT, 2)) + ' K')
    return I
# -----------------------------------------
def compute_pressure_profile_dry():
    # compute entropy from pressure and temperature
    # sg = Thermodynamics.entropy(self.Pg, self.Tg, self.qtg, 0.0, 0.0)
    def entropy_dry(pd, T, qt, ql, qi):
        print 'entropy dry'
        sd_c = sd_tilde + cpd * np.log(T / T_tilde) - Rd * np.log(pd / p_tilde)
        return sd_c

    # compute Temperature from pressure and entropy (dry)
    def eos(pd, s, qt):
        ql = np.zeros(pd.shape)
        qi = np.zeros(pd.shape)
        eos_c = T_tilde * (np.exp((s - sd_tilde + Rd * np.log(pd / p_tilde)) / cpd))
        return eos_c, ql, qi

    def rhs(p, z):
        ql = 0.0
        qi = 0.0
        # # given sfc values for pressure, temperature and moisture
        # # >> compute sfc entropy (= constant value throught atmosphere for reference profile being defines as constant-entropy profile)
        # # compute temperature from pressure and entropy (at any given height)
        T, ql, qi = eos(np.exp(p), sg, qtg)
        rhs_ = -g / (Rd * T * (1.0 - qtg + eps_vi * (qtg - ql - qi)))
        return rhs_

    sg = entropy_dry(Pg, Tg, qtg, 0.0, 0.0)
    p0 = np.log(Pg)
    # Construct arrays for integration points
    z_ = np.array(np.arange(nz) * dz)
    # Perform the integration
    p = odeint(rhs, p0, z_, hmax=1.0)[:, 0]  # type: object
    # p_half = odeint(rhs, p0, z_half, hmax=1.0)[1:, 0]
    p = np.exp(p)
    # temperature[k], ql[k], qi[k] = Thermodynamics.eos(p_[k], self.sg, self.qtg)
    # print('...', sg, qtg)
    T, ql, qi = eos(p, sg, qtg)
    # qv[k] = self.qtg - (ql[k] + qi[k])
    qv = np.zeros(p.shape)
    # alpha[k] = Thermodynamics.alpha(p_[k], temperature[k], self.qtg, qv[k])
    al = alpha_tot(T, p, qtg, qv)
    # al = alpha_dry(T, p)

    fig, axes = plt.subplots(1, 3, figsize=(24, 10))
    ax = axes[0]
    ax.plot(p, z_, '-')
    ax.set_title('pressure')
    ax = axes[1]
    ax.plot(T, z_, '-')
    ax.set_title('temperature')
    ax = axes[2]
    ax.plot(1./al, z_, '-')
    ax.plot([np.amin(1./al), np.amax(1./al)], [800, 800], 'k')
    # # ax.plot([3.0, 3.0],[0, 5000], 'k')
    ax.plot([1./al[np.int(800. / dz)], 1./al[np.int(800. / dz)]], [0, 2e3], 'k')
    ax.set_title('rho')
    plt.savefig('./thermodynamic_profiles_pycles.png')
    plt.close()

    return p, al


# -----------------------------------------

def alpha_tot(T, p0, qt, qv):
    # qd*alpha_dry + qv*alpha_moist, with qd=1-qt
    return Rd*T/p0 * (1.-qt+qv*eps_vi)

def alpha_dry(T, p0):
    return Rd*T / p0

def alpha_moist(T, p0):
    return Rv*T/p0

def exner_c(p0):
    return pow((p0/p_tilde),kappa)

# -----------------------------------------

if __name__ == '__main__':
    main()
